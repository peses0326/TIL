
### 하루 회고

- 클론코딩을 하면서 많은 부분에서 내가 이유없이 쓰는 코드가 생각보다 많다는 걸 느꼈다.
이유를 찾아가면서 하는게 중요하단걸 알지만, 또 한편으로는 일단 협업이기 때문에 프론트에서 작동을 하는 코드를 작성해서 넘겨주고 나서 리팩토링을 하면서 이유를 설명할 수 있게끔 한 스펙을 만들어서 다음에 있을 최종 프로젝트에 임하도록 해야겠다.

### 주저리 주저리

- 최종 프로젝트에 팀장으로 지원을 했다. 자신은 있지만, 부담이 된다. 내가 잘 못 이끌어서 나만 손해를 보면 자업자득이지만, 나를 믿고 같은 팀이 될 다른 분들을 위해서 더 열심히 움직여야 한다는 책임감이 막중하게 느껴진다.
- 남들은 내가 잘 한다고 생각하지만, 사실 맞다. 난 잘해 ㅎㅎ
가 아니라 그런 말을 들을 때면 스스로 으쓱하다가도 억지로 어깨를 내린다. 
모르는 개념, 이론이 한가득이고 정작 지금 내손으로 짠 코드도 잘 설명하지 못하는걸...
- 최소한 내가 작동할 줄 아는 기능들은 알고쓰자!

### 오늘 배운 것

# JPA Annotation

JPA를 사용하면 DB 데이터에 작업할 경우 실제 쿼리를 사용하지 않고 Entity 클래스의 수정을 통해 작업한다.

## @Entity

실제 DB의 테이블과 매칭될 Class임을 명시한다.즉, 테이블과 링크될 클래스임을 나타낸다.

### Entity Class

가장 Core한 클래스로 클래스 이름을 언더스코어 네이밍(_)으로 테이블 이름을 매칭한다.`SalesManage스.java -> sales_manager table`

### Controller에서 쓸 DTO 클래스란??

**Request와 Response용 DTO는 `View`를 위한 클래스**로, 자주 변경이 필요한 클래스이다.**Entity 클래스와 DTO 클래스를 분리하는 이유**는 **`View Layer`와 `DB Layer`를 철저하게 역할 분리하기 위해서다.**

**테이블과 매핑되는 Entity 클래스가 변경되면 여러 클래스에 영향을 끼치게 되는 반면 View와 통신하는 DTO 클래스(Request/ Response 클래스)는 자주 변경되므로 분리해야 한다.**

## @Table

Entity Class에 매핑할 테이블 정보를 알려준다.`@Table(name = "USER")`**Annotation을 생략하면 Class 이름을 테이블 이름 정보로 매핑**한다.

## @Id

해당 테이블의 **PK 필드를 나타낸다.**

## @GeneratedValue

**PK의 생성 규칙**을 나타낸다.*가능한 Entity의 PK는 Long 타입의 Auto_increment를 추천스프링 부트 2.0에선 옵션을 추가하셔야만 auto_increment가 된다.*

기본값은 AUTO로, MySQL의 auto_increment와 같이 자동 증가하는 정수형 값이 된다.

## @Column

**테이블의 컬럼**을 나타내며, 굳이 **선언하지 않더라도 해당 Class의 필드는 모두 컬럼이 된다.***@Column을 생략하면 필드명을 사용해서 컬럼명과 매핑*

`@Column(name = "username")**@Column`을 사용하는 이유**는, **기본값 외에 추가로 변경이 필요한 옵션이 있을 경우 사용**한다.

*문자열의 경우 VARCHAR(255)가 기본값인데, 사이즈를 500으로 늘리고 싶거나(ex: title),타입을 TEXT로 변경하고 싶거나(ex: content) 등의 경우에 사용*
